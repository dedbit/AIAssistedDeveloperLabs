// Generated by Copilot
using Microsoft.EntityFrameworkCore;
using Moq;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Xunit;

namespace AzureFunctions.Api.Tests
{
    /// <summary>
    /// Unit tests for Employee Repository focusing on GetCompensationAnalysisAsync method.
    /// Tests various scenarios including bucketing, filtering, and aggregation logic.
    /// </summary>
    public class EmployeeRepositoryTests
    {
        

        /// <summary>
        /// Tests compensation analysis with multiple salary buckets in the same department.
        /// Example: bucketSize = 25000, minEmployeeCount = 1
        /// </summary>
        [Fact]
        public async Task GetCompensationAnalysisAsync_WithMultipleBuckets_ReturnsCorrectGroups()
        {
            // Arrange
            var employees = new List<Employee>
            {
                new Employee { Id = 1, FirstName = "Alice", LastName = "Low", Department = "Sales", Salary = 30000m },
                new Employee { Id = 2, FirstName = "Bob", LastName = "Mid", Department = "Sales", Salary = 55000m },
                new Employee { Id = 3, FirstName = "Charlie", LastName = "High", Department = "Sales", Salary = 80000m }
            };

            var mockContext = CreateMockContext(employees);
            var repository = new EmployeeRepository(mockContext);

            // Act
            var result = await repository.GetCompensationAnalysisAsync(bucketSize: 25000m, minEmployeeCount: 1);
            var resultList = result.OrderBy(x => x.SalaryRangeMin).ToList();

            // Assert
            Assert.Equal(3, resultList.Count);
            
            // First bucket: $25K-$50K
            Assert.Equal(25000m, resultList[0].SalaryRangeMin);
            Assert.Equal(50000m, resultList[0].SalaryRangeMax);
            Assert.Equal(1, resultList[0].EmployeeCount);
            
            // Second bucket: $50K-$75K
            Assert.Equal(50000m, resultList[1].SalaryRangeMin);
            Assert.Equal(75000m, resultList[1].SalaryRangeMax);
            Assert.Equal(1, resultList[1].EmployeeCount);
            
            // Third bucket: $75K-$100K
            Assert.Equal(75000m, resultList[2].SalaryRangeMin);
            Assert.Equal(100000m, resultList[2].SalaryRangeMax);
            Assert.Equal(1, resultList[2].EmployeeCount);
        }

        /// <summary>
        /// Tests compensation analysis across multiple departments.
        /// Example: bucketSize = 25000, minEmployeeCount = 1
        /// </summary>
        [Fact]
        public async Task GetCompensationAnalysisAsync_WithMultipleDepartments_GroupsByDepartment()
        {
            // Arrange
            var employees = new List<Employee>
            {
                new Employee { Id = 1, FirstName = "John", LastName = "Eng1", Department = "Engineering", Salary = 50000m },
                new Employee { Id = 2, FirstName = "Jane", LastName = "Eng2", Department = "Engineering", Salary = 55000m },
                new Employee { Id = 3, FirstName = "Bob", LastName = "Sales1", Department = "Sales", Salary = 50000m },
                new Employee { Id = 4, FirstName = "Alice", LastName = "Sales2", Department = "Sales", Salary = 52000m }
            };

            var mockContext = CreateMockContext(employees);
            var repository = new EmployeeRepository(mockContext);

            // Act
            var result = await repository.GetCompensationAnalysisAsync(bucketSize: 25000m, minEmployeeCount: 1);
            var resultList = result.ToList();

            // Assert
            Assert.Equal(2, resultList.Count);
            Assert.Contains(resultList, r => r.Department == "Engineering" && r.EmployeeCount == 2);
            Assert.Contains(resultList, r => r.Department == "Sales" && r.EmployeeCount == 2);
        }

        /// <summary>
        /// Tests percentage calculation within department is accurate.
        /// Example: bucketSize = 25000, minEmployeeCount = 1
        /// </summary>
        [Fact]
        public async Task GetCompensationAnalysisAsync_CalculatesPercentageCorrectly()
        {
            // Arrange
            var employees = new List<Employee>
            {
                // 4 employees in Engineering, 2 in $50K-$75K bucket, 2 in $75K-$100K bucket
                new Employee { Id = 1, FirstName = "Eng1", LastName = "Low1", Department = "Engineering", Salary = 50000m },
                new Employee { Id = 2, FirstName = "Eng2", LastName = "Low2", Department = "Engineering", Salary = 55000m },
                new Employee { Id = 3, FirstName = "Eng3", LastName = "High1", Department = "Engineering", Salary = 75000m },
                new Employee { Id = 4, FirstName = "Eng4", LastName = "High2", Department = "Engineering", Salary = 80000m }
            };

            var mockContext = CreateMockContext(employees);
            var repository = new EmployeeRepository(mockContext);

            // Act
            var result = await repository.GetCompensationAnalysisAsync(bucketSize: 25000m, minEmployeeCount: 1);
            var resultList = result.OrderBy(x => x.SalaryRangeMin).ToList();

            // Assert
            Assert.Equal(2, resultList.Count);
            Assert.Equal(50m, resultList[0].PercentageOfDepartment); // 2 out of 4 = 50%
            Assert.Equal(50m, resultList[1].PercentageOfDepartment); // 2 out of 4 = 50%
        }


        /// <summary>
        /// Helper method to create an in-memory DbContext with test data.
        /// Uses EF Core InMemory provider to properly execute LINQ queries with Math operations.
        /// </summary>
        /// <param name="employees">List of employees to populate the context</param>
        /// <returns>DbContext configured with InMemory database</returns>
        private EmployeeDbContext CreateMockContext(List<Employee> employees)
        {
            var options = new DbContextOptionsBuilder<EmployeeDbContext>()
                .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString()) // Unique DB per test
                .Options;

            var context = new EmployeeDbContext(options);
            
            // Seed the database with test data
            if (employees.Any())
            {
                context.Employees.AddRange(employees);
                context.SaveChanges();
            }

            return context;
        }
    }

    #region Test Models (Add these to your actual project models)
    
    /// <summary>
    /// Employee entity representing an employee record.
    /// Note: This is a placeholder - replace with reference to your actual Employee entity.
    /// </summary>
    public class Employee
    {
        public int Id { get; set; }
        public string FirstName { get; set; }
        public string LastName { get; set; }
        public string Department { get; set; }
        public decimal Salary { get; set; }
    }

    /// <summary>
    /// DbContext for employee data.
    /// Note: This is a placeholder - replace with reference to your actual DbContext.
    /// </summary>
    public class EmployeeDbContext : DbContext
    {
        public EmployeeDbContext(DbContextOptions<EmployeeDbContext> options) : base(options)
        {
        }

        public virtual DbSet<Employee> Employees { get; set; }
    }

    /// <summary>
    /// Repository for employee data operations.
    /// Note: This is a placeholder - replace with reference to your actual repository.
    /// </summary>
    public class EmployeeRepository
    {
        private readonly EmployeeDbContext _context;

        public EmployeeRepository(EmployeeDbContext context)
        {
            _context = context;
        }

        /// <summary>
        /// Gets compensation analysis showing employee distribution across salary ranges by department.
        /// Uses complex EF Core query with grouping, filtering, joining, and salary bucketing.
        /// Example: bucketSize = 25000, minEmployeeCount = 1
        /// </summary>
        /// <param name="bucketSize">The salary range bucket size in dollars, e.g., 25000 for $25K buckets</param>
        /// <param name="minEmployeeCount">Minimum employees required to include a result, e.g., 1, 2, 5</param>
        /// <returns>List of compensation analysis grouped by salary range and department</returns>
        public async Task<IEnumerable<CompensationAnalysisDto>> GetCompensationAnalysisAsync(decimal bucketSize = 25000m, int minEmployeeCount = 1)
        {
            // Load employees into memory first to avoid complex query translation issues with InMemory provider
            var employees = await _context.Employees.ToListAsync();
            
            // Get department totals
            var departmentTotals = employees
                .GroupBy(e => e.Department)
                .ToDictionary(g => g.Key, g => g.Count());

            // Perform bucketing and analysis in memory
            var result = employees
                .Select(e => new
                {
                    Employee = e,
                    BucketMin = Math.Floor(e.Salary / bucketSize) * bucketSize,
                    BucketMax = (Math.Floor(e.Salary / bucketSize) + 1) * bucketSize
                })
                .GroupBy(x => new { x.BucketMin, x.BucketMax, x.Employee.Department })
                .Select(g => new
                {
                    g.Key.BucketMin,
                    g.Key.BucketMax,
                    g.Key.Department,
                    EmployeeCount = g.Count(),
                    AverageSalary = g.Average(x => x.Employee.Salary)
                })
                .Where(x => x.EmployeeCount >= minEmployeeCount)
                .OrderBy(x => x.Department)
                .ThenBy(x => x.BucketMin)
                .Select(x => new CompensationAnalysisDto
                {
                    SalaryRangeMin = x.BucketMin,
                    SalaryRangeMax = x.BucketMax,
                    SalaryRangeLabel = $"${x.BucketMin / 1000}K-${x.BucketMax / 1000}K",
                    Department = x.Department,
                    EmployeeCount = x.EmployeeCount,
                    AverageSalary = x.AverageSalary,
                    PercentageOfDepartment = departmentTotals.ContainsKey(x.Department) && departmentTotals[x.Department] > 0
                        ? Math.Round((decimal)x.EmployeeCount / departmentTotals[x.Department] * 100, 2)
                        : 0
                })
                .ToList();

            return result;
        }
    }

    /// <summary>
    /// DTO for compensation analysis results.
    /// Note: This is a placeholder - replace with reference to your actual DTO.
    /// </summary>
    public class CompensationAnalysisDto
    {
        public decimal SalaryRangeMin { get; set; }
        public decimal SalaryRangeMax { get; set; }
        public string SalaryRangeLabel { get; set; }
        public string Department { get; set; }
        public int EmployeeCount { get; set; }
        public decimal AverageSalary { get; set; }
        public decimal PercentageOfDepartment { get; set; }
    }

    #endregion
}
